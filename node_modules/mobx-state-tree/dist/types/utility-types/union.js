import * as tslib_1 from "tslib";
import { typeCheckSuccess, typeCheckFailure, flattenTypeErrors, isType, TypeFlags, Type, fail, isPlainObject } from "../../internal";
var Union = /** @class */ (function (_super) {
    tslib_1.__extends(Union, _super);
    function Union(name, types, options) {
        var _this = _super.call(this, name) || this;
        _this.eager = true;
        _this.dispatcher = options && options.dispatcher;
        if (options && !options.eager)
            _this.eager = false;
        _this.types = types;
        return _this;
    }
    Object.defineProperty(Union.prototype, "flags", {
        get: function () {
            var result = TypeFlags.Union;
            this.types.forEach(function (type) {
                result |= type.flags;
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Union.prototype, "shouldAttachNode", {
        get: function () {
            return this.types.some(function (type) { return type.shouldAttachNode; });
        },
        enumerable: true,
        configurable: true
    });
    Union.prototype.isAssignableFrom = function (type) {
        return this.types.some(function (subType) { return subType.isAssignableFrom(type); });
    };
    Union.prototype.describe = function () {
        return "(" + this.types.map(function (factory) { return factory.describe(); }).join(" | ") + ")";
    };
    Union.prototype.instantiate = function (parent, subpath, environment, value) {
        var type = this.determineType(value);
        if (!type)
            return fail("No matching type for union " + this.describe()); // can happen in prod builds
        return type.instantiate(parent, subpath, environment, value);
    };
    Union.prototype.reconcile = function (current, newValue) {
        var type = this.determineType(newValue);
        if (!type)
            return fail("No matching type for union " + this.describe()); // can happen in prod builds
        return type.reconcile(current, newValue);
    };
    Union.prototype.determineType = function (value) {
        // try the dispatcher, if defined
        if (this.dispatcher) {
            return this.dispatcher(value);
        }
        // find the most accomodating type
        return this.types.find(function (type) { return type.is(value); });
    };
    Union.prototype.isValidSnapshot = function (value, context) {
        if (this.dispatcher) {
            return this.dispatcher(value).validate(value, context);
        }
        var allErrors = [];
        var applicableTypes = 0;
        for (var i = 0; i < this.types.length; i++) {
            var type = this.types[i];
            var errors = type.validate(value, context);
            if (errors.length === 0) {
                if (this.eager)
                    return typeCheckSuccess();
                else
                    applicableTypes++;
            }
            else {
                allErrors.push(errors);
            }
        }
        if (applicableTypes === 1)
            return typeCheckSuccess();
        return typeCheckFailure(context, value, "No type is applicable for the union").concat(flattenTypeErrors(allErrors));
    };
    return Union;
}(Type));
export { Union };
/**
 * types.union(dispatcher?, types...) create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form (snapshot) => Type.
 *
 * @export
 * @alias types.union
 * @param {(ITypeDispatcher | IAnyType)} optionsOrType
 * @param {...IAnyType[]} otherTypes
 * @returns {IAnyType}
 */
export function union(optionsOrType) {
    var otherTypes = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        otherTypes[_i - 1] = arguments[_i];
    }
    var options = isType(optionsOrType) ? undefined : optionsOrType;
    var types = isType(optionsOrType) ? [optionsOrType].concat(otherTypes) : otherTypes;
    var name = "(" + types.map(function (type) { return type.name; }).join(" | ") + ")";
    // check all options
    if (process.env.NODE_ENV !== "production") {
        if (!isType(optionsOrType) && !isPlainObject(optionsOrType))
            fail("First argument to types.union should either be a type, or an objects object of the form: { eager?: boolean, dispatcher?: Function }");
        types.forEach(function (type) {
            if (!isType(type))
                fail("expected all possible types to be a mobx-state-tree type, got " +
                    type +
                    " instead");
        });
    }
    return new Union(name, types, options);
}
export function isUnionType(type) {
    return (type.flags & TypeFlags.Union) > 0;
}
//# sourceMappingURL=union.js.map