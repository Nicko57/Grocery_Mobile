import * as tslib_1 from "tslib";
import { fail, createNode, Type, TypeFlags, isType, typeCheckFailure, ModelType, typeCheckSuccess } from "../../internal";
var IdentifierType = /** @class */ (function (_super) {
    tslib_1.__extends(IdentifierType, _super);
    function IdentifierType() {
        var _this = _super.call(this, "identifier") || this;
        _this.shouldAttachNode = false;
        _this.flags = TypeFlags.Identifier;
        return _this;
    }
    IdentifierType.prototype.instantiate = function (parent, subpath, environment, snapshot) {
        if (!parent || !(parent.type instanceof ModelType))
            fail("Identifier types can only be instantiated as direct child of a model type");
        return createNode(this, parent, subpath, environment, snapshot);
    };
    IdentifierType.prototype.reconcile = function (current, newValue) {
        if (current.storedValue !== newValue)
            return fail("Tried to change identifier from '" + current.storedValue + "' to '" + newValue + "'. Changing identifiers is not allowed.");
        return current;
    };
    IdentifierType.prototype.describe = function () {
        return "identifier";
    };
    IdentifierType.prototype.isValidSnapshot = function (value, context) {
        if (typeof value !== "string") {
            return typeCheckFailure(context, value, "Value is not a valid identifier, expected a string");
        }
        return typeCheckSuccess();
    };
    return IdentifierType;
}(Type));
export { IdentifierType };
var IdentifierNumberType = /** @class */ (function (_super) {
    tslib_1.__extends(IdentifierNumberType, _super);
    function IdentifierNumberType() {
        var _this = _super.call(this) || this;
        _this.name = "identifierNumber";
        return _this;
    }
    IdentifierNumberType.prototype.instantiate = function (parent, subpath, environment, snapshot) {
        return _super.prototype.instantiate.call(this, parent, subpath, environment, snapshot);
    };
    IdentifierNumberType.prototype.isValidSnapshot = function (value, context) {
        if (typeof value === "number") {
            return typeCheckSuccess();
        }
        return typeCheckFailure(context, value, "Value is not a valid identifierNumber, expected a number");
    };
    IdentifierNumberType.prototype.reconcile = function (current, newValue) {
        return _super.prototype.reconcile.call(this, current, newValue);
    };
    IdentifierNumberType.prototype.getSnapshot = function (node) {
        return node.storedValue;
    };
    IdentifierNumberType.prototype.describe = function () {
        return "identifierNumber";
    };
    return IdentifierNumberType;
}(IdentifierType));
export { IdentifierNumberType };
/**
 * Identifiers are used to make references, lifecycle events and reconciling works.
 * Inside a state tree, for each type can exist only one instance for each given identifier.
 * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.
 * Identifier can be used only as type property of a model.
 * This type accepts as parameter the value type of the identifier field that can be either string or number.
 *
 * @example
 *  const Todo = types.model("Todo", {
 *      id: types.identifier,
 *      title: types.string
 *  })
 *
 * @export
 * @alias types.identifier
 * @template T
 * @returns {IType<T, T>}
 */
export var identifier = new IdentifierType();
/**
 * Similar to `types.identifier`, but `identifierNumber` will serialize from / to a number when applying snapshots
 *
 * @example
 *  const Todo = types.model("Todo", {
 *      id: types.identifierNumber,
 *      title: types.string
 *  })
 *
 * @export
 * @alias types.identifierNumber
 * @template T
 * @returns {IType<T, T>}
 */
export var identifierNumber = new IdentifierNumberType();
export function isIdentifierType(type) {
    return isType(type) && (type.flags & TypeFlags.Identifier) > 0;
}
//# sourceMappingURL=identifier.js.map