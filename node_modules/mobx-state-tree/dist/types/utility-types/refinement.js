import * as tslib_1 from "tslib";
import { isStateTreeNode, getStateTreeNode, Type, typeCheckSuccess, typeCheckFailure, isType, fail, TypeFlags } from "../../internal";
var Refinement = /** @class */ (function (_super) {
    tslib_1.__extends(Refinement, _super);
    function Refinement(name, type, predicate, message) {
        var _this = _super.call(this, name) || this;
        _this.type = type;
        _this.predicate = predicate;
        _this.message = message;
        return _this;
    }
    Object.defineProperty(Refinement.prototype, "flags", {
        get: function () {
            return this.type.flags | TypeFlags.Refinement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Refinement.prototype, "shouldAttachNode", {
        get: function () {
            return this.type.shouldAttachNode;
        },
        enumerable: true,
        configurable: true
    });
    Refinement.prototype.describe = function () {
        return this.name;
    };
    Refinement.prototype.instantiate = function (parent, subpath, environment, value) {
        // create the child type
        var inst = this.type.instantiate(parent, subpath, environment, value);
        return inst;
    };
    Refinement.prototype.isAssignableFrom = function (type) {
        return this.type.isAssignableFrom(type);
    };
    Refinement.prototype.isValidSnapshot = function (value, context) {
        var subtypeErrors = this.type.validate(value, context);
        if (subtypeErrors.length > 0)
            return subtypeErrors;
        var snapshot = isStateTreeNode(value) ? getStateTreeNode(value).snapshot : value;
        if (!this.predicate(snapshot)) {
            return typeCheckFailure(context, value, this.message(value));
        }
        return typeCheckSuccess();
    };
    return Refinement;
}(Type));
export { Refinement };
/**
 * `types.refinement(baseType, (snapshot) => boolean)` creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.
 *
 * @export
 * @alias types.refinement
 * @template T
 * @param {string} name
 * @param {IType<T, T>} type
 * @param {(snapshot: T) => boolean} predicate
 * @returns {IType<T, T>}
 */
export function refinement() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var name = typeof args[0] === "string" ? args.shift() : isType(args[0]) ? args[0].name : null;
    var type = args[0];
    var predicate = args[1];
    var message = args[2]
        ? args[2]
        : function (v) { return "Value does not respect the refinement predicate"; };
    // ensures all parameters are correct
    if (process.env.NODE_ENV !== "production") {
        if (typeof name !== "string")
            fail("expected a string as first argument, got " + name + " instead");
        if (!isType(type))
            fail("expected a mobx-state-tree type as first or second argument, got " +
                type +
                " instead");
        if (typeof predicate !== "function")
            fail("expected a function as third argument, got " + predicate + " instead");
        if (typeof message !== "function")
            fail("expected a function as fourth argument, got " + message + " instead");
    }
    return new Refinement(name, type, predicate, message);
}
export function isRefinementType(type) {
    return (type.flags & TypeFlags.Refinement) > 0;
}
//# sourceMappingURL=refinement.js.map