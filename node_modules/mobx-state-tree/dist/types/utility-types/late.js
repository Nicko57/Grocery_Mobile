import * as tslib_1 from "tslib";
import { fail, Type, TypeFlags, isType, typeCheckSuccess } from "../../internal";
var Late = /** @class */ (function (_super) {
    tslib_1.__extends(Late, _super);
    function Late(name, definition) {
        var _this = _super.call(this, name) || this;
        _this._subType = null;
        _this.definition = definition;
        return _this;
    }
    Object.defineProperty(Late.prototype, "flags", {
        get: function () {
            return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Late.prototype, "shouldAttachNode", {
        get: function () {
            return this.getSubType(true).shouldAttachNode;
        },
        enumerable: true,
        configurable: true
    });
    Late.prototype.getSubType = function (mustSucceed) {
        if (this._subType === null) {
            var t = undefined;
            try {
                t = this.definition();
            }
            catch (e) {
                if (e instanceof ReferenceError)
                    // can happen in strict ES5 code when a definition is self refering
                    t = undefined;
                else
                    throw e;
            }
            if (mustSucceed && t === undefined)
                fail("Late type seems to be used too early, the definition (still) returns undefined");
            if (t) {
                if (process.env.NODE_ENV !== "production" && !isType(t))
                    fail("Failed to determine subtype, make sure types.late returns a type definition.");
                this._subType = t;
                return t;
            }
        }
        return this._subType;
    };
    Late.prototype.instantiate = function (parent, subpath, environment, snapshot) {
        return this.getSubType(true).instantiate(parent, subpath, environment, snapshot);
    };
    Late.prototype.reconcile = function (current, newValue) {
        return this.getSubType(true).reconcile(current, newValue);
    };
    Late.prototype.describe = function () {
        var t = this.getSubType(false);
        return t ? t.name : "<uknown late type>";
    };
    Late.prototype.isValidSnapshot = function (value, context) {
        var t = this.getSubType(false);
        if (!t) {
            // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here
            return typeCheckSuccess();
        }
        return t.validate(value, context);
    };
    Late.prototype.isAssignableFrom = function (type) {
        var t = this.getSubType(false);
        return t ? t.isAssignableFrom(type) : false;
    };
    return Late;
}(Type));
export { Late };
/**
 * Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.
 * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.
 * You need to declare an interface to explicit the return type of the late parameter function.
 *
 * @example
 *  interface INode {
 *       childs: INode[]
 *  }
 *
 *   // TypeScript is'nt smart enough to infer self referencing types.
 *  const Node = types.model({
 *       childs: types.optional(types.array(types.late<any, INode>(() => Node)), [])
 *  })
 *
 * @export
 * @alias types.late
 * @template S
 * @template T
 * @param {string} [name] The name to use for the type that will be returned.
 * @param {ILateType<S, T>} type A function that returns the type that will be defined.
 * @returns {IType<S, T>}
 */
export function late(nameOrType, maybeType) {
    var name = typeof nameOrType === "string" ? nameOrType : "late(" + nameOrType.toString() + ")";
    var type = typeof nameOrType === "string" ? maybeType : nameOrType;
    // checks that the type is actually a late type
    if (process.env.NODE_ENV !== "production") {
        if (!(typeof type === "function" && type.length === 0))
            fail("Invalid late type, expected a function with zero arguments that returns a type, got: " +
                type);
    }
    return new Late(name, type);
}
export function isLateType(type) {
    return isType(type) && (type.flags & TypeFlags.Late) > 0;
}
//# sourceMappingURL=late.js.map