import * as tslib_1 from "tslib";
import { getStateTreeNode, isStateTreeNode, createNode, Type, TypeFlags, isType, typeCheckSuccess, typeCheckFailure, fail } from "../../internal";
import { computed } from "mobx";
var StoredReference = /** @class */ (function () {
    function StoredReference(mode, value, targetType) {
        this.mode = mode;
        this.value = value;
        this.targetType = targetType;
        if (mode === "object") {
            if (!isStateTreeNode(value))
                return fail("Can only store references to tree nodes, got: '" + value + "'");
            var targetNode = getStateTreeNode(value);
            if (!targetNode.identifierAttribute)
                return fail("Can only store references with a defined identifier attribute.");
        }
    }
    Object.defineProperty(StoredReference.prototype, "resolvedValue", {
        get: function () {
            // reference was initialized with the identifier of the target
            var _a = this, node = _a.node, targetType = _a.targetType;
            var target = node.root.identifierCache.resolve(targetType, this.value);
            if (!target)
                return fail("Failed to resolve reference '" + this.value + "' to type '" + this.targetType.name + "' (from node: " + node.path + ")");
            return target.value;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        computed
    ], StoredReference.prototype, "resolvedValue", null);
    return StoredReference;
}());
var BaseReferenceType = /** @class */ (function (_super) {
    tslib_1.__extends(BaseReferenceType, _super);
    function BaseReferenceType(targetType) {
        var _this = _super.call(this, "reference(" + targetType.name + ")") || this;
        _this.targetType = targetType;
        _this.shouldAttachNode = false;
        _this.flags = TypeFlags.Reference;
        return _this;
    }
    BaseReferenceType.prototype.describe = function () {
        return this.name;
    };
    BaseReferenceType.prototype.isAssignableFrom = function (type) {
        return this.targetType.isAssignableFrom(type);
    };
    BaseReferenceType.prototype.isValidSnapshot = function (value, context) {
        return typeof value === "string" || typeof value === "number"
            ? typeCheckSuccess()
            : typeCheckFailure(context, value, "Value is not a valid identifier, which is a string or a number");
    };
    return BaseReferenceType;
}(Type));
export { BaseReferenceType };
var IdentifierReferenceType = /** @class */ (function (_super) {
    tslib_1.__extends(IdentifierReferenceType, _super);
    function IdentifierReferenceType(targetType) {
        return _super.call(this, targetType) || this;
    }
    IdentifierReferenceType.prototype.getValue = function (node) {
        if (!node.isAlive)
            return undefined;
        var ref = node.storedValue;
        // id already resolved, return
        if (ref.mode === "object")
            return ref.value;
        return ref.resolvedValue;
    };
    IdentifierReferenceType.prototype.getSnapshot = function (node) {
        var ref = node.storedValue;
        switch (ref.mode) {
            case "identifier":
                return ref.value;
            case "object":
                return ref.value[getStateTreeNode(ref.value).identifierAttribute];
        }
    };
    IdentifierReferenceType.prototype.instantiate = function (parent, subpath, environment, snapshot) {
        var mode = isStateTreeNode(snapshot) ? "object" : "identifier";
        var r;
        var node = createNode(this, parent, subpath, environment, (r = new StoredReference(mode, snapshot, this.targetType)));
        r.node = node;
        return node;
    };
    IdentifierReferenceType.prototype.reconcile = function (current, newValue) {
        if (current.type === this) {
            var targetMode = isStateTreeNode(newValue) ? "object" : "identifier";
            var ref = current.storedValue;
            if (targetMode === ref.mode && ref.value === newValue)
                return current;
        }
        var newNode = this.instantiate(current.parent, current.subpath, current._environment, newValue);
        current.die();
        return newNode;
    };
    return IdentifierReferenceType;
}(BaseReferenceType));
export { IdentifierReferenceType };
var CustomReferenceType = /** @class */ (function (_super) {
    tslib_1.__extends(CustomReferenceType, _super);
    function CustomReferenceType(targetType, options) {
        var _this = _super.call(this, targetType) || this;
        _this.options = options;
        return _this;
    }
    CustomReferenceType.prototype.getValue = function (node) {
        if (!node.isAlive)
            return undefined;
        return this.options.get(node.storedValue, node.parent ? node.parent.storedValue : null);
    };
    CustomReferenceType.prototype.getSnapshot = function (node) {
        return node.storedValue;
    };
    CustomReferenceType.prototype.instantiate = function (parent, subpath, environment, snapshot) {
        var identifier = isStateTreeNode(snapshot)
            ? this.options.set(snapshot, parent ? parent.storedValue : null)
            : snapshot;
        return createNode(this, parent, subpath, environment, identifier);
    };
    CustomReferenceType.prototype.reconcile = function (current, snapshot) {
        var newIdentifier = isStateTreeNode(snapshot)
            ? this.options.set(snapshot, current ? current.storedValue : null)
            : snapshot;
        if (current.type === this) {
            if (current.storedValue === newIdentifier)
                return current;
        }
        var newNode = this.instantiate(current.parent, current.subpath, current._environment, newIdentifier);
        current.die();
        return newNode;
    };
    return CustomReferenceType;
}(BaseReferenceType));
export { CustomReferenceType };
/**
 * Creates a reference to another type, which should have defined an identifier.
 * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.
 *
 * @export
 * @alias types.reference
 */
export function reference(subType, options) {
    // check that a type is given
    if (process.env.NODE_ENV !== "production") {
        if (!isType(subType))
            fail("expected a mobx-state-tree type as first argument, got " + subType + " instead");
        if (arguments.length === 2 && typeof arguments[1] === "string")
            fail("References with base path are no longer supported. Please remove the base path.");
    }
    // as any because getValue might actually return undefined if the node is not alive
    if (options)
        return new CustomReferenceType(subType, options);
    else
        return new IdentifierReferenceType(subType);
}
export function isReferenceType(type) {
    return (type.flags & TypeFlags.Reference) > 0;
}
//# sourceMappingURL=reference.js.map