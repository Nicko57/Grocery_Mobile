import * as tslib_1 from "tslib";
import { _getAdministration, _interceptReads, action, computed, extendObservable, getAtom, intercept, isComputedProp, observable, observe, set } from "mobx";
import { addHiddenFinalProp, addHiddenWritableProp, ArrayType, ComplexType, createActionInvoker, createNode, EMPTY_ARRAY, EMPTY_OBJECT, escapeJsonPath, fail, flattenTypeErrors, freeze, getContextForPath, getPrimitiveFactoryFromValue, getStateTreeNode, isPlainObject, isPrimitive, isStateTreeNode, isType, MapType, mobxShallow, optional, typecheck, typeCheckFailure, TypeFlags } from "../../internal";
var PRE_PROCESS_SNAPSHOT = "preProcessSnapshot";
var POST_PROCESS_SNAPSHOT = "postProcessSnapshot";
export var HookNames;
(function (HookNames) {
    HookNames["afterCreate"] = "afterCreate";
    HookNames["afterAttach"] = "afterAttach";
    HookNames["beforeDetach"] = "beforeDetach";
    HookNames["beforeDestroy"] = "beforeDestroy";
})(HookNames || (HookNames = {}));
function objectTypeToString() {
    return getStateTreeNode(this).toString();
}
var defaultObjectOptions = {
    name: "AnonymousModel",
    properties: {},
    initializers: EMPTY_ARRAY
};
function toPropertiesObject(declaredProps) {
    // loop through properties and ensures that all items are types
    return Object.keys(declaredProps).reduce(function (props, key) {
        var _a, _b, _c;
        // warn if user intended a HOOK
        if (key in HookNames)
            return fail("Hook '" + key + "' was defined as property. Hooks should be defined as part of the actions");
        // the user intended to use a view
        var descriptor = Object.getOwnPropertyDescriptor(props, key);
        if ("get" in descriptor) {
            fail("Getters are not supported as properties. Please use views instead");
        }
        // undefined and null are not valid
        var value = descriptor.value;
        if (value === null || value === undefined) {
            fail("The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?");
            // its a primitive, convert to its type
        }
        else if (isPrimitive(value)) {
            return Object.assign({}, props, (_a = {},
                _a[key] = optional(getPrimitiveFactoryFromValue(value), value),
                _a));
            // map defaults to empty object automatically for models
        }
        else if (value instanceof MapType) {
            return Object.assign({}, props, (_b = {},
                _b[key] = optional(value, {}),
                _b));
        }
        else if (value instanceof ArrayType) {
            return Object.assign({}, props, (_c = {}, _c[key] = optional(value, []), _c));
            // its already a type
        }
        else if (isType(value)) {
            return props;
            // its a function, maybe the user wanted a view?
        }
        else if (process.env.NODE_ENV !== "production" && typeof value === "function") {
            fail("Invalid type definition for property '" + key + "', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?");
            // no other complex values
        }
        else if (process.env.NODE_ENV !== "production" && typeof value === "object") {
            fail("Invalid type definition for property '" + key + "', it looks like you passed an object. Try passing another model type or a types.frozen.");
            // WTF did you pass in mate?
        }
        else {
            fail("Invalid type definition for property '" + key + "', cannot infer a type from a value like '" + value + "' (" + typeof value + ")");
        }
    }, declaredProps);
}
var ModelType = /** @class */ (function (_super) {
    tslib_1.__extends(ModelType, _super);
    function ModelType(opts) {
        var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;
        _this.flags = TypeFlags.Object;
        _this.shouldAttachNode = true;
        var name = opts.name || defaultObjectOptions.name;
        // TODO: this test still needed?
        if (!/^\w[\w\d_]*$/.test(name))
            fail("Typename should be a valid identifier: " + name);
        Object.assign(_this, defaultObjectOptions, opts);
        // ensures that any default value gets converted to its related type
        _this.properties = toPropertiesObject(_this.properties);
        freeze(_this.properties); // make sure nobody messes with it
        _this.propertyNames = Object.keys(_this.properties);
        _this.identifierAttribute = _this._getIdentifierAttribute();
        return _this;
    }
    ModelType.prototype._getIdentifierAttribute = function () {
        var identifierAttribute = undefined;
        this.forAllProps(function (propName, propType) {
            if (propType.flags & TypeFlags.Identifier) {
                if (identifierAttribute)
                    fail("Cannot define property '" + propName + "' as object identifier, property '" + identifierAttribute + "' is already defined as identifier property");
                identifierAttribute = propName;
            }
        });
        return identifierAttribute;
    };
    ModelType.prototype.cloneAndEnhance = function (opts) {
        return new ModelType({
            name: opts.name || this.name,
            properties: Object.assign({}, this.properties, opts.properties),
            initializers: this.initializers.concat(opts.initializers || []),
            preProcessor: opts.preProcessor || this.preProcessor,
            postProcessor: opts.postProcessor || this.postProcessor
        });
    };
    ModelType.prototype.actions = function (fn) {
        var _this = this;
        var actionInitializer = function (self) {
            _this.instantiateActions(self, fn(self));
            return self;
        };
        return this.cloneAndEnhance({ initializers: [actionInitializer] });
    };
    ModelType.prototype.instantiateActions = function (self, actions) {
        // check if return is correct
        if (!isPlainObject(actions))
            fail("actions initializer should return a plain object containing actions");
        // bind actions to the object created
        Object.keys(actions).forEach(function (name) {
            // warn if preprocessor was given
            if (name === PRE_PROCESS_SNAPSHOT)
                fail("Cannot define action '" + PRE_PROCESS_SNAPSHOT + "', it should be defined using 'type.preProcessSnapshot(fn)' instead");
            // warn if postprocessor was given
            if (name === POST_PROCESS_SNAPSHOT)
                fail("Cannot define action '" + POST_PROCESS_SNAPSHOT + "', it should be defined using 'type.postProcessSnapshot(fn)' instead");
            // apply hook composition
            var action = actions[name];
            var baseAction = self[name];
            if (name in HookNames && baseAction) {
                var specializedAction_1 = action;
                action = function () {
                    baseAction.apply(null, arguments);
                    specializedAction_1.apply(null, arguments);
                };
            }
            // See #646, allow models to be mocked
            ;
            (process.env.NODE_ENV === "production" ? addHiddenFinalProp : addHiddenWritableProp)(self, name, createActionInvoker(self, name, action));
        });
    };
    ModelType.prototype.named = function (name) {
        return this.cloneAndEnhance({ name: name });
    };
    ModelType.prototype.props = function (properties) {
        return this.cloneAndEnhance({ properties: properties });
    };
    ModelType.prototype.volatile = function (fn) {
        var _this = this;
        var stateInitializer = function (self) {
            _this.instantiateVolatileState(self, fn(self));
            return self;
        };
        return this.cloneAndEnhance({ initializers: [stateInitializer] });
    };
    ModelType.prototype.instantiateVolatileState = function (self, state) {
        // check views return
        if (!isPlainObject(state))
            fail("volatile state initializer should return a plain object containing state");
        set(self, state);
    };
    ModelType.prototype.extend = function (fn) {
        var _this = this;
        var initializer = function (self) {
            var _a = fn(self), actions = _a.actions, views = _a.views, state = _a.state, rest = tslib_1.__rest(_a, ["actions", "views", "state"]);
            for (var key in rest)
                fail("The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '" + key + "'");
            if (state)
                _this.instantiateVolatileState(self, state);
            if (views)
                _this.instantiateViews(self, views);
            if (actions)
                _this.instantiateActions(self, actions);
            return self;
        };
        return this.cloneAndEnhance({ initializers: [initializer] });
    };
    ModelType.prototype.views = function (fn) {
        var _this = this;
        var viewInitializer = function (self) {
            _this.instantiateViews(self, fn(self));
            return self;
        };
        return this.cloneAndEnhance({ initializers: [viewInitializer] });
    };
    ModelType.prototype.instantiateViews = function (self, views) {
        // check views return
        if (!isPlainObject(views))
            fail("views initializer should return a plain object containing views");
        Object.keys(views).forEach(function (key) {
            // is this a computed property?
            var descriptor = Object.getOwnPropertyDescriptor(views, key);
            var value = descriptor.value;
            if ("get" in descriptor) {
                if (isComputedProp(self, key)) {
                    var computedValue = _getAdministration(self, key);
                    // TODO: mobx currently does not allow redefining computes yet, pending #1121
                    // FIXME: this binds to the internals of mobx!
                    computedValue.derivation = descriptor.get;
                    computedValue.scope = self;
                    if (descriptor.set)
                        computedValue.setter = action(computedValue.name + "-setter", descriptor.set);
                }
                else {
                    // use internal api as shortcut
                    ;
                    computed(self, key, descriptor, true);
                }
            }
            else if (typeof value === "function") {
                // this is a view function, merge as is!
                // See #646, allow models to be mocked
                ;
                (process.env.NODE_ENV === "production"
                    ? addHiddenFinalProp
                    : addHiddenWritableProp)(self, key, value);
            }
            else {
                fail("A view member should either be a function or getter based property");
            }
        });
    };
    ModelType.prototype.preProcessSnapshot = function (preProcessor) {
        var currentPreprocessor = this.preProcessor;
        if (!currentPreprocessor)
            return this.cloneAndEnhance({ preProcessor: preProcessor });
        else
            return this.cloneAndEnhance({
                preProcessor: function (snapshot) { return currentPreprocessor(preProcessor(snapshot)); }
            });
    };
    ModelType.prototype.postProcessSnapshot = function (postProcessor) {
        var currentPostprocessor = this.postProcessor;
        if (!currentPostprocessor)
            return this.cloneAndEnhance({ postProcessor: postProcessor });
        else
            return this.cloneAndEnhance({
                postProcessor: function (snapshot) { return postProcessor(currentPostprocessor(snapshot)); }
            });
    };
    ModelType.prototype.instantiate = function (parent, subpath, environment, snapshot) {
        var initialValue = isStateTreeNode(snapshot)
            ? snapshot
            : this.applySnapshotPreProcessor(snapshot);
        return createNode(this, parent, subpath, environment, initialValue, this.createNewInstance, this.finalizeNewInstance);
        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class
        // that pre-reserves all these fields for fast object-member lookups
    };
    ModelType.prototype.initializeChildNodes = function (objNode, initialSnapshot) {
        if (initialSnapshot === void 0) { initialSnapshot = {}; }
        var type = objNode.type;
        var result = {};
        type.forAllProps(function (name, childType) {
            result[name] = childType.instantiate(objNode, name, objNode._environment, initialSnapshot[name]);
        });
        return result;
    };
    ModelType.prototype.createNewInstance = function () {
        var instance = observable.object(EMPTY_OBJECT, EMPTY_OBJECT, mobxShallow);
        addHiddenFinalProp(instance, "toString", objectTypeToString);
        return instance;
    };
    ModelType.prototype.finalizeNewInstance = function (node, childNodes) {
        var objNode = node;
        var type = objNode.type;
        var instance = objNode.storedValue;
        extendObservable(instance, childNodes, EMPTY_OBJECT, mobxShallow);
        type.forAllProps(function (name) {
            _interceptReads(instance, name, objNode.unbox);
        });
        type.initializers.reduce(function (self, fn) { return fn(self); }, instance);
        intercept(instance, type.willChange);
        observe(instance, type.didChange);
    };
    ModelType.prototype.willChange = function (change) {
        var node = getStateTreeNode(change.object);
        node.assertWritable();
        var type = node.type.properties[change.name];
        // only properties are typed, state are stored as-is references
        if (type) {
            typecheck(type, change.newValue);
            change.newValue = type.reconcile(node.getChildNode(change.name), change.newValue);
        }
        return change;
    };
    ModelType.prototype.didChange = function (change) {
        var node = getStateTreeNode(change.object);
        var type = node.type.properties[change.name];
        if (!type) {
            // don't emit patches for volatile state
            return;
        }
        var oldValue = change.oldValue ? change.oldValue.snapshot : undefined;
        node.emitPatch({
            op: "replace",
            path: escapeJsonPath(change.name),
            value: change.newValue.snapshot,
            oldValue: oldValue
        }, node);
    };
    ModelType.prototype.getChildren = function (node) {
        var _this = this;
        var res = [];
        this.forAllProps(function (name, type) {
            res.push(_this.getChildNode(node, name));
        });
        return res;
    };
    ModelType.prototype.getChildNode = function (node, key) {
        if (!(key in this.properties))
            return fail("Not a value property: " + key);
        var childNode = _getAdministration(node.storedValue, key).value; // TODO: blegh!
        if (!childNode)
            return fail("Node not available for property " + key);
        return childNode;
    };
    ModelType.prototype.getValue = function (node) {
        return node.storedValue;
    };
    ModelType.prototype.getSnapshot = function (node, applyPostProcess) {
        var _this = this;
        if (applyPostProcess === void 0) { applyPostProcess = true; }
        var res = {};
        this.forAllProps(function (name, type) {
            // TODO: FIXME, make sure the observable ref is used!
            ;
            getAtom(node.storedValue, name).reportObserved();
            res[name] = _this.getChildNode(node, name).snapshot;
        });
        if (applyPostProcess) {
            return this.applySnapshotPostProcessor(res);
        }
        return res;
    };
    ModelType.prototype.processInitialSnapshot = function (childNodes, snapshot) {
        var processed = {};
        Object.keys(childNodes).forEach(function (key) {
            processed[key] = childNodes[key].getSnapshot();
        });
        return this.applySnapshotPostProcessor(this.applyOptionalValuesToSnapshot(processed));
    };
    ModelType.prototype.applyPatchLocally = function (node, subpath, patch) {
        if (!(patch.op === "replace" || patch.op === "add"))
            fail("object does not support operation " + patch.op);
        node.storedValue[subpath] = patch.value;
    };
    ModelType.prototype.applySnapshot = function (node, snapshot) {
        var s = this.applySnapshotPreProcessor(snapshot);
        typecheck(this, s);
        this.forAllProps(function (name, type) {
            node.storedValue[name] = s[name];
        });
    };
    ModelType.prototype.applySnapshotPreProcessor = function (snapshot) {
        var processor = this.preProcessor;
        return processor ? processor.call(null, snapshot) : snapshot;
    };
    ModelType.prototype.applyOptionalValuesToSnapshot = function (snapshot) {
        if (snapshot) {
            snapshot = Object.assign({}, snapshot);
            this.forAllProps(function (name, type) {
                if (!(name in snapshot)) {
                    var optional_1 = tryGetOptional(type);
                    if (optional_1) {
                        snapshot[name] = optional_1.getDefaultValueSnapshot();
                    }
                }
            });
        }
        return snapshot;
    };
    ModelType.prototype.applySnapshotPostProcessor = function (snapshot) {
        var postProcessor = this.postProcessor;
        if (postProcessor)
            return postProcessor.call(null, snapshot);
        return snapshot;
    };
    ModelType.prototype.getChildType = function (key) {
        return this.properties[key];
    };
    ModelType.prototype.isValidSnapshot = function (value, context) {
        var _this = this;
        var snapshot = this.applySnapshotPreProcessor(value);
        if (!isPlainObject(snapshot)) {
            return typeCheckFailure(context, snapshot, "Value is not a plain object");
        }
        return flattenTypeErrors(this.propertyNames.map(function (key) {
            return _this.properties[key].validate(snapshot[key], getContextForPath(context, key, _this.properties[key]));
        }));
    };
    ModelType.prototype.forAllProps = function (fn) {
        var _this = this;
        this.propertyNames.forEach(function (key) { return fn(key, _this.properties[key]); });
    };
    ModelType.prototype.describe = function () {
        var _this = this;
        // optimization: cache
        return ("{ " +
            this.propertyNames.map(function (key) { return key + ": " + _this.properties[key].describe(); }).join("; ") +
            " }");
    };
    ModelType.prototype.getDefaultSnapshot = function () {
        return {};
    };
    ModelType.prototype.removeChild = function (node, subpath) {
        node.storedValue[subpath] = null;
    };
    tslib_1.__decorate([
        action
    ], ModelType.prototype, "applySnapshot", null);
    return ModelType;
}(ComplexType));
export { ModelType };
/**
 * Creates a new model type by providing a name, properties, volatile state and actions.
 *
 * See the [model type](https://github.com/mobxjs/mobx-state-tree#creating-models) description or the [getting started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started-1) tutorial.
 *
 * @export
 * @alias types.model
 */
export function model() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var name = typeof args[0] === "string" ? args.shift() : "AnonymousModel";
    var properties = args.shift() || {};
    return new ModelType({ name: name, properties: properties });
}
/**
 * Composes a new model from one or more existing model types.
 * This method can be invoked in two forms:
 * Given 2 or more model types, the types are composed into a new Type.
 * Given first parameter as a string and 2 or more model types,
 * the types are composed into a new Type with the given name
 *
 * @export
 * @alias types.compose
 */
export function compose() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // TODO: just join the base type names if no name is provided
    var typeName = typeof args[0] === "string" ? args.shift() : "AnonymousModel";
    // check all parameters
    if (process.env.NODE_ENV !== "production") {
        args.forEach(function (type) {
            if (!isType(type))
                fail("expected a mobx-state-tree type, got " + type + " instead");
        });
    }
    return args
        .reduce(function (prev, cur) {
        return prev.cloneAndEnhance({
            name: prev.name + "_" + cur.name,
            properties: cur.properties,
            initializers: cur.initializers
        });
    })
        .named(typeName);
}
export function isModelType(type) {
    return isType(type) && (type.flags & TypeFlags.Object) > 0;
}
function tryGetOptional(type) {
    if (!type)
        return undefined;
    // we need to check for type.types since an optional union doesn't have direct subtypes
    if (type.flags & TypeFlags.Union && type.types)
        return type.types.find(tryGetOptional);
    if (type.flags & TypeFlags.Late && type.getSubType && type.getSubType(false))
        return tryGetOptional(type.subType);
    if (type.flags & TypeFlags.Optional)
        return type;
    return undefined;
}
//# sourceMappingURL=model.js.map