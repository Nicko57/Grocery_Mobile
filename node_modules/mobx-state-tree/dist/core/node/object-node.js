import * as tslib_1 from "tslib";
// noinspection ES6UnusedImports
import { action, computed, createAtom, reaction } from "mobx";
import { addHiddenFinalProp, addReadOnlyProp, convertChildNodesToArray, createActionInvoker, escapeJsonPath, extend, fail, freeze, getStateTreeNode, IdentifierCache, invalidateComputed, isStateTreeNode, NodeLifeCycle, registerEventHandler, resolveNodeByPathParts, splitJsonPath, splitPatch, toJSON, walk } from "../../internal";
var nextNodeId = 1;
var livelynessChecking = "warn";
/**
 *  Defines what MST should do when running into reads / writes to objects that have died.
 * By default it will print a warning.
 * Use te `"error"` option to easy debugging to see where the error was thrown and when the offending read / write took place
 *
 * Possible values: `"warn"`, `"error"` and `"ignore"`
 *
 * @export
 * @param {LivelynessMode} mode
 */
export function setLivelynessChecking(mode) {
    livelynessChecking = mode;
}
var snapshotReactionOptions = {
    onError: function (e) {
        throw e;
    }
};
var NOT_FILLED_REF = {};
var ObjectNode = /** @class */ (function () {
    function ObjectNode(type, parent, subpath, environment, initialSnapshot, createNewInstance, finalizeNewInstance) {
        this.nodeId = ++nextNodeId;
        this.subpathAtom = createAtom("path");
        this.subpath = "";
        this.parent = null;
        this.state = NodeLifeCycle.INITIALIZING;
        this.isProtectionEnabled = true;
        this.middlewares = null;
        this._autoUnbox = true; // unboxing is disabled when reading child nodes
        this._environment = undefined;
        this._isRunningAction = false; // only relevant for root
        this._hasSnapshotReaction = false;
        this._disposers = null;
        this._patchSubscribers = null;
        this._snapshotSubscribers = null;
        this._observableInstanceCreated = false;
        this._cachedInitialSnapshot = null;
        this._environment = environment;
        this._initialSnapshot = freeze(initialSnapshot);
        this._createNewInstance = createNewInstance;
        this._finalizeNewInstance = finalizeNewInstance;
        this.type = type;
        this.parent = parent;
        this.subpath = subpath;
        this.escapedSubpath = escapeJsonPath(this.subpath);
        this.identifierAttribute = type.identifierAttribute;
        // identifier can not be changed during lifecycle of a node
        // so we safely can read it from initial snapshot
        this.identifier =
            this.identifierAttribute && this._initialSnapshot
                ? "" + this._initialSnapshot[this.identifierAttribute] // normalize internal identifier to string
                : null;
        if (!parent) {
            this.identifierCache = new IdentifierCache();
        }
        this._childNodes = type.initializeChildNodes(this, this._initialSnapshot);
        if (!parent) {
            this.identifierCache.addNodeToCache(this);
        }
        else {
            parent.root.identifierCache.addNodeToCache(this);
        }
    }
    ObjectNode.prototype.applyPatches = function (patches) {
        if (!this._observableInstanceCreated)
            this._createObservableInstance();
        this.applyPatches(patches);
    };
    ObjectNode.prototype.applySnapshot = function (snapshot) {
        if (!this._observableInstanceCreated)
            this._createObservableInstance();
        this.applySnapshot(snapshot);
    };
    ObjectNode.prototype._createObservableInstance = function () {
        this.storedValue = this._createNewInstance(this._childNodes);
        this.preboot();
        addHiddenFinalProp(this.storedValue, "$treenode", this);
        addHiddenFinalProp(this.storedValue, "toJSON", toJSON);
        this._observableInstanceCreated = true;
        var sawException = true;
        try {
            this._isRunningAction = true;
            this._finalizeNewInstance(this, this._childNodes);
            this._isRunningAction = false;
            this.fireHook("afterCreate");
            this.state = NodeLifeCycle.CREATED;
            sawException = false;
        }
        finally {
            if (sawException) {
                // short-cut to die the instance, to avoid the snapshot computed starting to throw...
                this.state = NodeLifeCycle.DEAD;
            }
        }
        // NOTE: we need to touch snapshot, because non-observable
        // "observableInstanceCreated" field was touched
        invalidateComputed(this, "snapshot");
        if (this.isRoot)
            this._addSnapshotReaction();
        this.finalizeCreation();
        this._childNodes = null;
        this._createNewInstance = null;
        this._finalizeNewInstance = null;
    };
    Object.defineProperty(ObjectNode.prototype, "path", {
        /*
         * Returnes (escaped) path representation as string
         */
        get: function () {
            this.subpathAtom.reportObserved();
            if (!this.parent)
                return "";
            return this.parent.path + "/" + this.escapedSubpath;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectNode.prototype, "root", {
        get: function () {
            var parent = this.parent;
            return parent ? parent.root : this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectNode.prototype, "isRoot", {
        get: function () {
            return this.parent === null;
        },
        enumerable: true,
        configurable: true
    });
    ObjectNode.prototype.setParent = function (newParent, subpath) {
        if (subpath === void 0) { subpath = null; }
        if (this.parent === newParent && this.subpath === subpath)
            return;
        if (newParent && process.env.NODE_ENV !== "production") {
            if (this.parent && newParent !== this.parent) {
                fail("A node cannot exists twice in the state tree. Failed to add " + this + " to path '" + newParent.path + "/" + subpath + "'.");
            }
            if (!this.parent && newParent.root === this) {
                fail("A state tree is not allowed to contain itself. Cannot assign " + this + " to path '" + newParent.path + "/" + subpath + "'");
            }
            if (!this.parent &&
                !!this.root._environment &&
                this.root._environment !== newParent.root._environment) {
                fail("A state tree cannot be made part of another state tree as long as their environments are different.");
            }
        }
        if (this.parent && !newParent) {
            this.die();
        }
        else {
            var newPath = subpath === null ? "" : subpath;
            if (this.subpath !== newPath) {
                this.subpath = newPath;
                this.escapedSubpath = escapeJsonPath(this.subpath);
                this.subpathAtom.reportChanged();
            }
            if (newParent && newParent !== this.parent) {
                newParent.root.identifierCache.mergeCache(this);
                this.parent = newParent;
                this.subpathAtom.reportChanged();
                this.fireHook("afterAttach");
            }
        }
    };
    ObjectNode.prototype.fireHook = function (name) {
        var fn = this.storedValue && typeof this.storedValue === "object" && this.storedValue[name];
        if (typeof fn === "function")
            fn.apply(this.storedValue);
    };
    Object.defineProperty(ObjectNode.prototype, "value", {
        get: function () {
            if (!this._observableInstanceCreated)
                this._createObservableInstance();
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectNode.prototype, "_value", {
        get: function () {
            if (!this.isAlive)
                return undefined;
            return this.type.getValue(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectNode.prototype, "snapshot", {
        // advantage of using computed for a snapshot is that nicely respects transactions etc.
        get: function () {
            if (!this.isAlive)
                return undefined;
            return freeze(this.getSnapshot());
        },
        enumerable: true,
        configurable: true
    });
    // NOTE: we use this method to get snapshot without creating @computed overhead
    ObjectNode.prototype.getSnapshot = function () {
        if (!this.isAlive)
            return undefined;
        return this._observableInstanceCreated
            ? this._getActualSnapshot()
            : this._getInitialSnapshot();
    };
    ObjectNode.prototype._getActualSnapshot = function () {
        return this.type.getSnapshot(this);
    };
    ObjectNode.prototype._getInitialSnapshot = function () {
        if (!this.isAlive)
            return undefined;
        if (!this._initialSnapshot)
            return this._initialSnapshot;
        if (this._cachedInitialSnapshot)
            return this._cachedInitialSnapshot;
        var type = this.type;
        var childNodes = this._childNodes;
        var snapshot = this._initialSnapshot;
        this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);
        return this._cachedInitialSnapshot;
    };
    ObjectNode.prototype.isRunningAction = function () {
        if (this._isRunningAction)
            return true;
        if (this.isRoot)
            return false;
        return this.parent.isRunningAction();
    };
    Object.defineProperty(ObjectNode.prototype, "isAlive", {
        get: function () {
            return this.state !== NodeLifeCycle.DEAD;
        },
        enumerable: true,
        configurable: true
    });
    ObjectNode.prototype.assertAlive = function () {
        if (!this.isAlive) {
            var baseMsg = "[mobx-state-tree][error] You are trying to read or write to an object that is no longer part of a state tree. (Object type was '" + this.type.name + "'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.";
            switch (livelynessChecking) {
                case "error":
                    throw new Error(baseMsg);
                case "warn":
                    console.warn(baseMsg +
                        ' Use setLivelynessChecking("error") to simplify debugging this error.');
            }
        }
    };
    ObjectNode.prototype.getChildNode = function (subpath) {
        this.assertAlive();
        this._autoUnbox = false;
        try {
            return this._observableInstanceCreated
                ? this.type.getChildNode(this, subpath)
                : this._childNodes[subpath];
        }
        finally {
            this._autoUnbox = true;
        }
    };
    ObjectNode.prototype.getChildren = function () {
        this.assertAlive();
        this._autoUnbox = false;
        try {
            return this._observableInstanceCreated
                ? this.type.getChildren(this)
                : convertChildNodesToArray(this._childNodes);
        }
        finally {
            this._autoUnbox = true;
        }
    };
    ObjectNode.prototype.getChildType = function (key) {
        return this.type.getChildType(key);
    };
    Object.defineProperty(ObjectNode.prototype, "isProtected", {
        get: function () {
            return this.root.isProtectionEnabled;
        },
        enumerable: true,
        configurable: true
    });
    ObjectNode.prototype.assertWritable = function () {
        this.assertAlive();
        if (!this.isRunningAction() && this.isProtected) {
            fail("Cannot modify '" + this + "', the object is protected and can only be modified by using an action.");
        }
    };
    ObjectNode.prototype.removeChild = function (subpath) {
        this.type.removeChild(this, subpath);
    };
    ObjectNode.prototype.unbox = function (childNode) {
        if (childNode && childNode.parent)
            childNode.parent.assertAlive();
        if (childNode && childNode.parent && childNode.parent._autoUnbox)
            return childNode.value;
        return childNode;
    };
    ObjectNode.prototype.toString = function () {
        var identifier = this.identifier ? "(id: " + this.identifier + ")" : "";
        return this.type.name + "@" + (this.path || "<root>") + identifier + (this.isAlive ? "" : "[dead]");
    };
    ObjectNode.prototype.finalizeCreation = function () {
        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already
        if (this.state === NodeLifeCycle.CREATED) {
            if (this.parent) {
                if (this.parent.state !== NodeLifeCycle.FINALIZED) {
                    // parent not ready yet, postpone
                    return;
                }
                this.fireHook("afterAttach");
            }
            this.state = NodeLifeCycle.FINALIZED;
            for (var _i = 0, _a = this.getChildren(); _i < _a.length; _i++) {
                var child = _a[_i];
                if (child instanceof ObjectNode)
                    child.finalizeCreation();
            }
        }
    };
    ObjectNode.prototype.detach = function () {
        if (!this.isAlive)
            fail("Error while detaching, node is not alive.");
        if (this.isRoot)
            return;
        else {
            this.fireHook("beforeDetach");
            this._environment = this.root._environment; // make backup of environment
            this.state = NodeLifeCycle.DETACHING;
            this.identifierCache = this.root.identifierCache.splitCache(this);
            this.parent.removeChild(this.subpath);
            this.parent = null;
            this.subpath = this.escapedSubpath = "";
            this.subpathAtom.reportChanged();
            this.state = NodeLifeCycle.FINALIZED;
        }
    };
    ObjectNode.prototype.preboot = function () {
        var self = this;
        this.applyPatches = createActionInvoker(this.storedValue, "@APPLY_PATCHES", function (patches) {
            patches.forEach(function (patch) {
                var parts = splitJsonPath(patch.path);
                var node = resolveNodeByPathParts(self, parts.slice(0, -1));
                node.applyPatchLocally(parts[parts.length - 1], patch);
            });
        });
        this.applySnapshot = createActionInvoker(this.storedValue, "@APPLY_SNAPSHOT", function (snapshot) {
            // if the snapshot is the same as the current one, avoid performing a reconcile
            if (snapshot === self.snapshot)
                return;
            // else, apply it by calling the type logic
            return self.type.applySnapshot(self, snapshot);
        });
    };
    ObjectNode.prototype.die = function () {
        if (this.state === NodeLifeCycle.DETACHING)
            return;
        if (isStateTreeNode(this.storedValue)) {
            // optimization: don't use walk, but getChildNodes for more efficiency
            walk(this.storedValue, function (child) {
                var node = getStateTreeNode(child);
                if (node instanceof ObjectNode)
                    node.aboutToDie();
            });
            walk(this.storedValue, function (child) {
                var node = getStateTreeNode(child);
                if (node instanceof ObjectNode)
                    node.finalizeDeath();
            });
        }
    };
    ObjectNode.prototype.aboutToDie = function () {
        if (this._disposers) {
            this._disposers.forEach(function (f) { return f(); });
            this._disposers = null;
        }
        this.fireHook("beforeDestroy");
    };
    ObjectNode.prototype.finalizeDeath = function () {
        // invariant: not called directly but from "die"
        this.root.identifierCache.notifyDied(this);
        addReadOnlyProp(this, "snapshot", this.snapshot); // kill the computed prop and just store the last snapshot
        if (this._patchSubscribers)
            this._patchSubscribers = null;
        if (this._snapshotSubscribers)
            this._snapshotSubscribers = null;
        this.state = NodeLifeCycle.DEAD;
        this.subpath = this.escapedSubpath = "";
        this.parent = null;
        this.subpathAtom.reportChanged();
    };
    ObjectNode.prototype.onSnapshot = function (onChange) {
        this._addSnapshotReaction();
        if (!this._snapshotSubscribers)
            this._snapshotSubscribers = [];
        return registerEventHandler(this._snapshotSubscribers, onChange);
    };
    ObjectNode.prototype.emitSnapshot = function (snapshot) {
        if (this._snapshotSubscribers)
            this._snapshotSubscribers.forEach(function (f) { return f(snapshot); });
    };
    ObjectNode.prototype.onPatch = function (handler) {
        if (!this._patchSubscribers)
            this._patchSubscribers = [];
        return registerEventHandler(this._patchSubscribers, handler);
    };
    ObjectNode.prototype.emitPatch = function (basePatch, source) {
        var patchSubscribers = this._patchSubscribers;
        if (patchSubscribers && patchSubscribers.length) {
            var localizedPatch = extend({}, basePatch, {
                path: source.path.substr(this.path.length) + "/" + basePatch.path // calculate the relative path of the patch
            });
            var _a = splitPatch(localizedPatch), patch_1 = _a[0], reversePatch_1 = _a[1];
            patchSubscribers.forEach(function (f) { return f(patch_1, reversePatch_1); });
        }
        if (this.parent)
            this.parent.emitPatch(basePatch, source);
    };
    ObjectNode.prototype.addDisposer = function (disposer) {
        if (!this._disposers)
            this._disposers = [disposer];
        else
            this._disposers.unshift(disposer);
    };
    ObjectNode.prototype.removeMiddleware = function (handler) {
        if (this.middlewares)
            this.middlewares = this.middlewares.filter(function (middleware) { return middleware.handler !== handler; });
    };
    ObjectNode.prototype.addMiddleWare = function (handler, includeHooks) {
        var _this = this;
        if (includeHooks === void 0) { includeHooks = true; }
        if (!this.middlewares)
            this.middlewares = [{ handler: handler, includeHooks: includeHooks }];
        else
            this.middlewares.push({ handler: handler, includeHooks: includeHooks });
        return function () {
            _this.removeMiddleware(handler);
        };
    };
    ObjectNode.prototype.applyPatchLocally = function (subpath, patch) {
        this.assertWritable();
        if (!this._observableInstanceCreated)
            this._createObservableInstance();
        this.type.applyPatchLocally(this, subpath, patch);
    };
    ObjectNode.prototype._addSnapshotReaction = function () {
        var _this = this;
        if (!this._hasSnapshotReaction) {
            var snapshotDisposer = reaction(function () { return _this.snapshot; }, function (snapshot) { return _this.emitSnapshot(snapshot); }, snapshotReactionOptions);
            this.addDisposer(snapshotDisposer);
            this._hasSnapshotReaction = true;
        }
    };
    tslib_1.__decorate([
        action
    ], ObjectNode.prototype, "_createObservableInstance", null);
    tslib_1.__decorate([
        computed
    ], ObjectNode.prototype, "snapshot", null);
    tslib_1.__decorate([
        action
    ], ObjectNode.prototype, "detach", null);
    tslib_1.__decorate([
        action
    ], ObjectNode.prototype, "die", null);
    return ObjectNode;
}());
export { ObjectNode };
//# sourceMappingURL=object-node.js.map