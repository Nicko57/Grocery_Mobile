import { action as mobxAction } from "mobx";
import { getStateTreeNode, fail, argsToArray, getRoot, EMPTY_ARRAY, HookNames } from "../internal";
var nextActionId = 1;
var currentActionContext = null;
export function getNextActionId() {
    return nextActionId++;
}
// TODO: optimize away entire action context if there is no middleware in tree?
export function runWithActionContext(context, fn) {
    var node = getStateTreeNode(context.context);
    var baseIsRunningAction = node._isRunningAction;
    var prevContext = currentActionContext;
    if (context.type === "action") {
        node.assertAlive();
    }
    node._isRunningAction = true;
    currentActionContext = context;
    try {
        return runMiddleWares(node, context, fn);
    }
    finally {
        currentActionContext = prevContext;
        node._isRunningAction = baseIsRunningAction;
    }
}
export function getActionContext() {
    if (!currentActionContext)
        return fail("Not running an action!");
    return currentActionContext;
}
export function createActionInvoker(target, name, fn) {
    var res = function () {
        var id = getNextActionId();
        return runWithActionContext({
            type: "action",
            name: name,
            id: id,
            args: argsToArray(arguments),
            context: target,
            tree: getRoot(target),
            rootId: currentActionContext ? currentActionContext.rootId : id,
            parentId: currentActionContext ? currentActionContext.id : 0
        }, fn);
    };
    res._isMSTAction = true;
    return res;
}
/**
 * Middleware can be used to intercept any action is invoked on the subtree where it is attached.
 * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.
 *
 * For more details, see the [middleware docs](docs/middleware.md)
 *
 * @export
 * @param {IStateTreeNode} target
 * @param {(action: IRawActionCall, next: (call: IRawActionCall) => any) => any} middleware
 * @returns {IDisposer}
 */
export function addMiddleware(target, handler, includeHooks) {
    if (includeHooks === void 0) { includeHooks = true; }
    var node = getStateTreeNode(target);
    if (process.env.NODE_ENV !== "production") {
        if (!node.isProtectionEnabled)
            console.warn("It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`");
    }
    return node.addMiddleWare(handler, includeHooks);
}
/**
 * Binds middleware to a specific action
 *
 * @example
 * type.actions(self => {
 *   function takeA____() {
 *       self.toilet.donate()
 *       self.wipe()
 *       self.wipe()
 *       self.toilet.flush()
 *   }
 *   return {
 *     takeA____: decorate(atomic, takeA____)
 *   }
 * })
 *
 * @export
 * @template T
 * @param {IMiddlewareHandler} handler
 * @param Function} fn
 * @returns the original function
 */
export function decorate(handler, fn) {
    var middleware = { handler: handler, includeHooks: true };
    if (fn.$mst_middleware)
        fn.$mst_middleware.push(middleware);
    else
        fn.$mst_middleware = [middleware];
    return fn;
}
function collectMiddlewares(node, baseCall, fn) {
    var middlewares = fn.$mst_middleware || EMPTY_ARRAY;
    var n = node;
    // Find all middlewares. Optimization: cache this?
    while (n) {
        if (n.middlewares)
            middlewares = middlewares.concat(n.middlewares);
        n = n.parent;
    }
    return middlewares;
}
function runMiddleWares(node, baseCall, originalFn) {
    var middlewares = collectMiddlewares(node, baseCall, originalFn);
    // Short circuit
    if (!middlewares.length)
        return mobxAction(originalFn).apply(null, baseCall.args);
    var index = 0;
    var result = null;
    function runNextMiddleware(call) {
        var middleware = middlewares[index++];
        var handler = middleware && middleware.handler;
        var nextInvoked = false;
        var abortInvoked = false;
        function next(call, callback) {
            nextInvoked = true;
            // the result can contain
            // - the non manipulated return value from an action
            // - the non manipulated abort value
            // - one of the above but manipulated through the callback function
            if (callback) {
                result = callback(runNextMiddleware(call) || result);
            }
            else {
                result = runNextMiddleware(call);
            }
        }
        function abort(value) {
            abortInvoked = true;
            // overwrite the result
            // can be manipulated through middlewares earlier in the queue using the callback fn
            result = value;
        }
        var invokeHandler = function () {
            handler(call, next, abort);
            if (process.env.NODE_ENV !== "production") {
                if (!nextInvoked && !abortInvoked) {
                    var node_1 = getStateTreeNode(call.tree);
                    fail("Neither the next() nor the abort() callback within the middleware " + handler.name + " for the action: \"" + call.name + "\" on the node: " + node_1.type.name + " was invoked.");
                }
                if (nextInvoked && abortInvoked) {
                    var node_2 = getStateTreeNode(call.tree);
                    fail("The next() and abort() callback within the middleware " + handler.name + " for the action: \"" + call.name + "\" on the node: " + node_2.type.name + " were invoked.");
                }
            }
            return result;
        };
        if (handler && middleware.includeHooks) {
            return invokeHandler();
        }
        else if (handler && !middleware.includeHooks) {
            if (HookNames[call.name])
                return runNextMiddleware(call);
            return invokeHandler();
        }
        else {
            return mobxAction(originalFn).apply(null, call.args);
        }
    }
    return runNextMiddleware(baseCall);
}
//# sourceMappingURL=action.js.map